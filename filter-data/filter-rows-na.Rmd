---
title: "Filter rows with NA values"
output: 
  html_document:
    anchor_sections: FALSE
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(comment = NA,
                      message = FALSE,
                      warning = FALSE)
```

### Package: dplyr

---

#### Function: `filter()`

Examples of filtering while keeping NA values

---

**1\. Remove any row where extra2 is equal to -999, while also keeping rows that have NA for extra2.**

Review the data (d5).

```{r, echo=FALSE}

source("data.R")
d5

```


Filter out any row that has -999 for extra2.

* Note: Youâ€™ll notice that I make an explicit call to keep rows with NA values for extra2 in addition to removing rows with the value of -999 for extra2, using the *|* operator to denote and/or. A drawback of the filter function is that if you filter on a certain variable (such as extra2) it will not only filter out the values you request but it will also drop any row that has NA for that variable. And we may not necessarily want that. In this case, I want to keep the last row of data that has NA for extra2.

```{r}

d5 %>% 
  dplyr::filter(extra2 != -999 | is.na(extra2))

```

Another way to get around the issue of dropping NAs is to use the within operator *%in%* rather than *==* to make sure we keep the NA values for extra2. The *==* (or *!=*) is a logical operator that retains/drops rows that produce a value of TRUE for all conditions (and NA cannot be evaluated and is therefore dropped). However *%in%* matches values and therefore doesn't drop NA. 

```{r}

d5 %>% 
  dplyr::filter(!(extra2 %in% -999))

```


**2\. Remove any row that has -999 for extra2 *AND/OR* has -999 for extra3, while also keeping rows that have NA values for those variables.**

Review the data (d5)

```{r, echo=FALSE}

source("data.R")
d5

```

Filter out any row that has -999 for extra2 and/or -999 for extra3 (retaining any row that has NA values for those variables). 

* Note: You'll notice that I again make an explicit call to **keep** rows with NA values for extra2 and extra3, using the `|` operator to denote and/or.

* Note: Notice that for the first part of the equation I put the operator *!* outside of the parentheses. While there are other ways to write this equation, I find this the least confusing way to remove rows based on criteria from multiple variables.

```{r}

d5 %>% 
  dplyr::filter(!(extra2 == -999 | extra3 == -999) | (is.na(extra2) | is.na(extra3)))

```

Again, another way to get around the issue of dropping NAs is to use the within operator *%in%* rather than *==*.

```{r}

d5 %>% 
  dplyr::filter(!(extra2 %in% -999 | extra3 %in% -999))

```

**3\. Remove any row that has -999 for *AT LEAST ONE* numeric variable.**

Review the data (d9)

```{r, echo=FALSE}

source("data.R")
d9

```

Filter out any row that has -999 for **AT LEAST ONE** numeric variable

* Note: You can read `dplyr::if_any()` here as, keep rows where ANY numeric variables are NOT -999 (notice the ! on the outside of the `dplyr::if_any()` function)

* Note: You'll notice here that I used *%in%* rather than *==* to ensure I keep the NA values. 

```{r}

d9 %>% 
  dplyr::filter(!dplyr::if_any(is.numeric, ~ . %in% -999))

```

---

#### Function: `filter()`

Examples of filtering on NA values

---

**1\. Remove any row that has NA for extra2.**

Review the data (d7).

```{r, echo=FALSE}

source("data.R")
d7

```

Remove any row that has NA for extra2.

* Note: Use the logical operator *!* to denote NOT.

```{r}

d7 %>% 
  dplyr::filter(!is.na(extra2))

```

**2\. Remove any row that has NA for extra2 AND/OR extra3.**

Review the data (d7).

```{r, echo=FALSE}

source("data.R")
d7

```

* Note: Notice that I put the operator ! outside of the parentheses. While there are other ways to write this equation, I find this the least confusing way to remove rows based on removal criteria from multiple variables.

```{r}

d7 %>% 
  dplyr::filter(!(is.na(extra2) | is.na(extra3)))

```

**3\. Keep rows where extra2 is NA but extra3 is not NA**

Review the data (d10).

```{r, echo=FALSE}

source("data.R")
d10

```

Keep rows where extra2 is NA but extra3 is not NA

```{r}

d10 %>%
  dplyr::filter(is.na(extra2) & !is.na(extra3))
```


**4\. Remove any row that has NA for *ALL* numeric variables.**

Review the data (d9)

```{r, echo=FALSE}

source("data.R")
d9

```

Filter out any row that has NA for **ALL** numeric variables

* Note: You can read `dplyr::if_all()` here as, keep rows where ALL numeric variables are NOT NA (notice the ! on the outside of the `dplyr::if_all()` function)


```{r}

d9 %>% 
  dplyr::filter(!dplyr::if_all(is.numeric, ~ is.na(.)))


```

### Package: tidyr

---

#### Function: `tidyr::drop_na()`

---

**1\. Remove any rows where stu_id is NA**

Review the data (d7)

```{r, echo=FALSE}

source("data.R")
d7

```


Filter out any row that has NA for stu_id.

```{r}

d7 %>% 
  tidyr::drop_na(stu_id)


```


**2\. Remove any row that has an NA value for any variable**

Review the data (d7)

```{r, echo=FALSE}

source("data.R")
d7

```

Filter out any row that has NA for any variable.

```{r}

d7 %>% 
  tidyr::drop_na()


```

Return to [Filter](https://github.com/Cghlewis/data-wrangling-functions/wiki/Filter)
