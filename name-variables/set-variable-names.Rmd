---
title: "Set all variable names"
output: 
  html_document:
    anchor_sections: FALSE
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(comment = NA,
                      message = FALSE,
                      warning = FALSE)
```

<br>

### Package: purrr

---

#### Function: `set_names()`

---

**1\. Set all variable names.**

Review the data (d7)

* Note: In this example you had a file, such as a csv file, with no variable names. You'll see that when you read the file in, R assigned variable names of X1, X2 and X3 in this instance.

```{r, echo=FALSE}

source("data.R")
d7

```

You can review the variable names using `base::names()`.

```{r}

names(d7)

```


Add variable names

* Note: Quotes are required around variable names and the number of variable names given must be equal to the number of variables in the data frame.

```{r}

d7 %>% purrr::set_names("id", "grade", "test1")

```



### Package: dplyr

---

#### Function: `rename_with()`

---

* Note: `dplyr::rename_with()` renames columns using a function. You can either rename all variables or select variables. The default argument is *.cols = everything()*.

<br>

**1\. Set column names using an existing file (for example a data dictionary).**

Review the data (d1)

```{r echo = FALSE}

source("data.R")
d1

```

Read in and review the data dictionary

```{r, eval = FALSE}

dict <- readxl::read_excel("dictionary.xlsx")

```

```{r, echo = FALSE}

source("data.R")
dict

```

In this case we can use the existing file to rename the variables for us, rather than us hand entering "stu_id = Var1, read_score = Var2, math_score = Var3". You can see how this would save us time if we have many variables to rename.

* Note: We use `stringr::str_replace_all()` to replace all variable names and we use `purrr::set_names()` to set names using our dictionary.

```{r}

d1 %>%
 dplyr::rename_with(~ stringr::str_replace_all(., purrr::set_names(dict$label, dict$question)))

```

Even if the data dictionary is not in the same order as the variables in our data frame, the renaming will still work because it is renaming by matching the values in the 2 variables. For example, here is the dictionary in a different order.

```{r}

dict2

```

And we can still use this to rename our variables.

```{r}

d1 %>%
 dplyr::rename_with(~ stringr::str_replace_all(., purrr::set_names(dict2$label, dict2$question)))

```

We can also use this dictionary, even if it doesn't not have new names for all of our variables. Take this dictionary that can only relabel 2 of our variables.

```{r}

dict3

```

We can still rename.

```{r}

d1 %>%
 dplyr::rename_with(~ stringr::str_replace_all(., purrr::set_names(dict3$label, dict3$question)))

```
