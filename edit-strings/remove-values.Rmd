---
title: "Remove values"
output: 
  html_document:
    toc: false
    anchor_sections: FALSE
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(comment = NA,
                      message = FALSE,
                      warning = FALSE)
```

<br>

### Package: stringr

---

#### Function: `str_trim()`

---

**1\. Remove spaces from a variable**

Review the data (d1)

```{r, echo=FALSE}

d1 <- haven::read_sav("data.sav")

d1

```
I see that item1 comes in as character and I want it to be numeric. So I first try to recode the variable to numeric.

```{r}

d1 %>% 
  dplyr::mutate(item1 = as.numeric(item1))

```


---

#### Function: `rowMeans()`

---


**1\. Calculate a mean score ("measure_mean") for each student even with missing data**

Review the data (d2)

```{r, echo=FALSE}

source("data.R")
d2

```

Calculate the mean score of item1, item2, and item3

* Note: We are calculating a new variable using `dplyr::mutate()`

* Note: Adding `dplyr::across()` allows you to select the specific columns you want to calculate the rowSums for. Otherwise rowSums will be applied across all columns.
 
* Note: The default for NA values in your columns is to **not** calculate a sum if any NA value exists. If you want to still calculate a sum despite missing values, you can set the argument to *na.rm = TRUE*.

```{r}

d2 %>% 
  dplyr::mutate(measure_mean = rowMeans(dplyr::across(c(item1:item3)), na.rm=TRUE))

```

You can set the number of decimal places you want the new variable to have by wrapping the calculation in the function `base::round()` and setting the digits equal to the number you want.

* Note: It is very important to note how `base::round()` does rounding. It rounds to the even number when rounding at 5. This is not your normal way of thinking of rounding. When you have a value of 23.5, it will round up to 24. When you have a value of 22.5, it will round down to 22. However, when you round with 1 or more digits, since decimal places are not represented exactly, you may get different results depending on your OS: 1.75 may round to 1.7 or 1.8. See documentation on round for more information.

```{r}

d2 %>% 
  dplyr::mutate(measure_mean = round(rowMeans(dplyr::across(c(item1:item3)), na.rm=TRUE), digits= 2))

```

**2\. Calculate a mean score ("toca_mean") for all the variables that begin with "toca", for each student even with missing data**

Review the data (d5)

```{r, echo=FALSE}

source("data.R")
d5

```

Calculate the mean toca score

* Note: We use the `tidyselect` selection helper `starts_with()` to refer to all variables that start with the word "toca".

* Note: Other `tidyselect` selection helpers include `contains()`, `ends_with()`, `matches`, `num_range`, `where` and more.

```{r}

d5 %>% 
  dplyr::mutate(
    toca_mean = rowMeans(
      dplyr::across(tidyselect::starts_with("toca")), na.rm=TRUE))

```

If you wanted to exclude some of the "toca" items (say just toca2), you could exclude them this way, by wrapping your selected and excluded variables in c(). 

```{r}

d5 %>% 
  dplyr::mutate(
    toca_mean = rowMeans(
      dplyr::across(c(tidyselect::starts_with("toca"), -toca2)), na.rm=TRUE))

```

**3\. Calculate a mean score ("toca_mean") for all the variables that begin with "toca", when the toca variables contain _labelled na values_**

Review the data (d6)

```{r, echo=FALSE}

source("data.R")
d6

```

Let's review the labelled NA values. 

```{r, echo = FALSE}

library(labelled)

d6 <- d6 %>%
  mutate(across(contains("toca"), 
  ~(`na_values<-`(., c(-99)))))

```

```{r}

d6 %>%
  labelled::na_values()

```

We see that **-99** is labelled as an NA value for the toca variables. However, R does not recognize this as an NA value when calculating row scores. 

So first we will need to recode these to NA before creating our mean score.

* Note: We use `dplyr::mutate()` to create new temporary versions of our toca variables.

* Note: We use `base::ifelse()` to say if our current toca variables (denoted by .) are equal to 6, then make them NA, otherwise keep the value as is. Using `dplyr::if_else()` gives us errors in this process. I'm not sure why except that I read the function is more strict in checking that all alternatives are of the same variable type compared to using `base::ifelse()`. 

* Note: We use the `dplyr::across()` *.names* arugment to rename these variable to have the suffix "_temp" because we do not want to alter our original toca variables.

Second we calculate our mean score within `dplyr::mutate()` statement.

* Note: We add `dplyr::across()` to select multiple variables and use `tidyselect::contains()` to select all variables with the word "temp".

* Note: We also use the *na.rm* = TRUE argument to calculate the mean despite missing values.

* Note: Again we could add `base::round()` to round the number of decimal places in our mean if we wanted to

Last we drop our temporary toca variables using `dplyr::select()`. We don't need them anymore.


```{r}

d6 %>% 
  dplyr::mutate(dplyr::across(contains("toca"), 
                ~ ifelse(.==-99,NA,.),
                .names = "{col}_temp"),
                toca_mean = rowMeans(
           dplyr::across(tidyselect::contains("temp"), 
           na.rm = TRUE))) %>%
  dplyr::select(-tidyselect::contains("temp"))


```


<br>

### Package: dplyr

---

#### Function: `rowwise()`

---

**1\. Calculate a sum score for each student called "measure_sum"**

Review the data (d2)

```{r, echo=FALSE}

source("data.R")
d2

```

Calculate the sum score.

* Note: Again we are using `dplyr::mutate()` to create a new variable
* Note: The default for NA values in your columns is to not calculate a sum if any NA value exists. If you want to still calculate a sum despite missing values, you can set the argument to *na.rm = TRUE*.

```{r}

d2 %>%
  dplyr::rowwise() %>%
  dplyr::mutate(measure_sum = sum(c(item1, item2, item3)))

```

If you don't want to list out every single item in a measure, you can use `dplyr::c_across()` which uses tidy selection syntax to select variables. It is essentially a combination of c() and `dplyr::across()`. So instead of `mutate(measure_sum = dplyr::across(c(item1:item3)))`, you can simplify to the code below.

* Note: `dplyr::c_across()` cannot be used with `base::rowSums()` and `base::rowMeans()` because those functions take a different type of input compared to `dplyr::rowwise()`

```{r}

d2 %>%
  dplyr::rowwise() %>%
  dplyr::mutate(measure_sum = sum(dplyr::c_across(item1:item3)))


```

**2\. Calculate a mean score ("measure_mean") for each student even with missing data**

Review the data (d2)

```{r, echo=FALSE}

source("data.R")
d2

```

Calculate the mean score 

* Note: Again we are using `dplyr::mutate()` to create a new variable
* Note: We use `base::mean()` here to calculate mean
* Note: We use `dplyr::c_across()` to select the variables of interest

```{r}

d2 %>%
  dplyr::rowwise() %>%
  dplyr::mutate(measure_mean = mean(dplyr::c_across(item1:item3), na.rm=TRUE))

```


You can set the number of decimal places you want the new variable to have by wrapping the calculation in the function `base::round()` and setting the digits equal to the number you want.

* Note: `base::round()` rounds to the even digit for any .5 digit. Meaning when you have 0.5, it will round down to 0, and when you have 1.5 it will round up to 2.

```{r}

d2 %>%
  dplyr::rowwise() %>%
  dplyr::mutate(measure_mean = round(mean(c_across(item1:item3), na.rm=TRUE), digits=2))

```


**3\. Calculate a mean score ("toca_mean") for all the variables that contain the word "toca", for each student even with missing data**

Review the data (d4)

```{r, echo=FALSE}

source("data.R")
d4

```

Calculate the mean toca score

* Note: We use the `tidyselect` selection helper `contains()` to refer to all variables.

* Note: Other `tidyselect` selection helpers include `startswith()`, `ends_with()`, `matches`, `num_range`, `where` and more.

```{r}

d4 %>%
  dplyr::rowwise() %>%
  dplyr::mutate(toca_mean = mean(dplyr::c_across(tidyselect::contains("toca")), na.rm=TRUE))

```

Again, if you wanted to exclude some of the "toca" items (say toca2 and toca4 this time), you could exclude them this way, by wrapping your selected and excluded variables in c(). 

```{r}

d4 %>%
  dplyr::rowwise() %>%
  dplyr::mutate(toca_mean = mean(dplyr::c_across(c(tidyselect::contains("toca"), -c(toca2, toca4))), na.rm=TRUE))

```

<br>

### Package: janitor

---

#### Function: `adorn_totals()`

---

**1\. Calculate a sum score for each student called "measure_sum"**

Review the data (d2)

```{r, echo=FALSE}

source("data.R")
d2

```


Calculate the sum score

* Note: We can add the argument *where = "col"* to denote we want rows summed across columns rather than the default which is column totals

* Note: We can add the argument *name = * to rename the new column what we want rather than the default "Total"

* Note: The argument default for the NA argumen tis *na.rm = TRUE* so in this case, if we don't want a sum when there is missing data, we need to change it to FALSE.

```{r}

d2 %>% 
  janitor::adorn_totals(where = "col", name = "measure_sum", na.rm = FALSE)

```

Return to [Calculate Row Values](https://github.com/Cghlewis/data-wrangling-functions/wiki/Calculate Row Values)
